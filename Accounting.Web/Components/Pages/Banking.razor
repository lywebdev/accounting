@page "/banking"
@using Microsoft.AspNetCore.Components.Forms
@using Accounting.Web.Api.Banking
@using Microsoft.AspNetCore.WebUtilities
@using System.Net.Http.Headers
@inject IInvoiceService InvoiceService
@inject ISnackbar Snackbar
@inject HttpClient Http
@inject IStringLocalizer<SharedResources> Localizer
@inject ILogger<Banking> Logger
@implements IDisposable

<MudPaper Class="pa-4 mb-4">
    <MudStack Spacing="2">
        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Spacing="2">
            <MudText Typo="Typo.h5">@Localizer["Banking_Title"]</MudText>
            <MudStack Row="true" Spacing="2">
                <MudTooltip Text="@Localizer["Banking_Tooltip_Sync"]">
                    <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="SyncExternalAsync">
                        <MudIcon Icon="@Icons.Material.Filled.CloudDownload" Class="mr-2" />@Localizer["Banking_Sync"]
                    </MudButton>
                </MudTooltip>
                <MudTooltip Text="@Localizer["Banking_Tooltip_FileUpload"]">
                    <MudFileUpload T="IBrowserFile" @bind-Files="_importFile" Accept=".csv" />
                </MudTooltip>
                <MudTooltip Text="@Localizer["Banking_Tooltip_Import"]">
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="_importFile is null" OnClick="ImportCsvAsync">
                        <MudIcon Icon="@Icons.Material.Filled.Upload" Class="mr-2" />@Localizer["Banking_ImportCsv"]
                    </MudButton>
                </MudTooltip>
                <MudTooltip Text="@Localizer["Banking_Tooltip_AutoMatch"]">
                    <MudButton Variant="Variant.Outlined" Color="Color.Info" OnClick="TriggerAutoMatchAsync" Disabled="@_isLoading">
                        <MudIcon Icon="@Icons.Material.Filled.AutoAwesome" Class="mr-2" />@Localizer["Banking_Action_AutoMatch"]
                    </MudButton>
                </MudTooltip>
            </MudStack>
        </MudStack>
        <MudStack Row="true" AlignItems="AlignItems.End" Spacing="2">
            <MudDatePicker @bind-Date="_filterFrom" Label="@Localizer["Banking_Filter_From"]" DateFormat="yyyy-MM-dd" />
            <MudDatePicker @bind-Date="_filterTo" Label="@Localizer["Banking_Filter_To"]" DateFormat="yyyy-MM-dd" />
            <MudSelect T="bool?" Label="@Localizer["Banking_Filter_Status"]" @bind-Value="_filterMatched">
                <MudSelectItem Value="@((bool?)null)">@Localizer["Banking_Filter_Status_All"]</MudSelectItem>
                <MudSelectItem Value="@((bool?)true)">@Localizer["Banking_Filter_Status_Matched"]</MudSelectItem>
                <MudSelectItem Value="@((bool?)false)">@Localizer["Banking_Filter_Status_Unmatched"]</MudSelectItem>
            </MudSelect>
            <MudTextField @bind-Value="_searchTerm" Label="@Localizer["Banking_Filter_Search"]" />
            <MudNumericField @bind-Value="_amountMin" Label="@Localizer["Banking_Filter_AmountMin"]" />
            <MudNumericField @bind-Value="_amountMax" Label="@Localizer["Banking_Filter_AmountMax"]" />
            <MudTooltip Text="@Localizer["Banking_Tooltip_Filter"]">
                <MudButton Variant="Variant.Outlined" Color="Color.Primary" OnClick="LoadTransactionsAsync">
                    <MudIcon Icon="@Icons.Material.Filled.FilterList" Class="mr-2" />@Localizer["Banking_Filter_Apply"]
                </MudButton>
            </MudTooltip>
        </MudStack>
    </MudStack>
</MudPaper>

<MudPaper Class="report-note">
    @Localizer["Banking_Note"]
</MudPaper>
<MudPaper Class="pa-4 mb-4">
    <MudText Typo="Typo.subtitle1" Class="mb-2">@Localizer["Banking_Onboarding_Title"]</MudText>
    <MudList Dense="true" T="string">
        <MudListItem T="string">@Localizer["Banking_Onboarding_Step1"]</MudListItem>
        <MudListItem T="string">@Localizer["Banking_Onboarding_Step2"]</MudListItem>
        <MudListItem T="string">@Localizer["Banking_Onboarding_Step3"]</MudListItem>
    </MudList>
</MudPaper>

@if (_lastOperationSummary is not null)
{
    <MudAlert Severity="Severity.Info" Elevation="0" Dense="true" Class="mb-4">
        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
            <span>@Localizer["Banking_Summary_Message", _lastOperationSummary.Source, _lastOperationSummary.ImportedCount, _lastOperationSummary.MatchedCount, _lastOperationSummary.JournalEntries]</span>
            <MudIconButton Icon="@Icons.Material.Filled.Close" Size="Size.Small" OnClick="() => _lastOperationSummary = null" />
        </MudStack>
    </MudAlert>
}

@{
    var filteredTransactions = FilteredTransactions.ToList();
}

<MudTable T="BankTransactionRow" Items="filteredTransactions" Dense="true" Hover="true" Loading="@_isLoading" OnRowClick="HandleRowClick" RowClassFunc='@((_, __) => "clickable-row")'>
    <LoadingContent>
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
    </LoadingContent>
    <HeaderContent>
        <MudTh>@Localizer["Banking_Table_Date"]</MudTh>
        <MudTh>@Localizer["Banking_Table_Counterparty"]</MudTh>
        <MudTh>@Localizer["Banking_Table_Reference"]</MudTh>
        <MudTh>@Localizer["Banking_Table_Amount"]</MudTh>
        <MudTh>@Localizer["Banking_Table_Status"]</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd DataLabel="@Localizer["Banking_Table_Date"]">@context.BookingDate.ToString("yyyy-MM-dd")</MudTd>
        <MudTd DataLabel="@Localizer["Banking_Table_Counterparty"]">@context.Counterparty</MudTd>
        <MudTd DataLabel="@Localizer["Banking_Table_Reference"]">@context.Reference</MudTd>
        <MudTd DataLabel="@Localizer["Banking_Table_Amount"]">@($"{context.Amount:0.00} EUR")</MudTd>
        <MudTd DataLabel="@Localizer["Banking_Table_Status"]">
            @{
                var statusLabel = context.MatchedInvoiceId.HasValue
                    ? (context.JournalEntryId.HasValue ? Localizer["Banking_Status_Posted"] : Localizer["Banking_Status_Matched"])
                    : Localizer["Banking_Status_Unmatched"];
                var statusColor = context.MatchedInvoiceId.HasValue
                    ? (context.JournalEntryId.HasValue ? Color.Info : Color.Success)
                    : Color.Warning;
            }
            <MudChip T="string" Color="@statusColor">
                @statusLabel
            </MudChip>
        </MudTd>
    </RowTemplate>
</MudTable>
@if (!_isLoading && filteredTransactions.Count == 0)
{
    <MudAlert Severity="Severity.Info" Dense="true" Class="mt-3">
        <MudText>@Localizer["Banking_Empty_Hint"]</MudText>
        <MudStack Row="true" Spacing="1" Class="mt-2">
            <MudButton Variant="Variant.Outlined" OnClick="SyncExternalAsync">@Localizer["Banking_Sync"]</MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="LoadTransactionsAsync">@Localizer["Banking_Filter_Apply"]</MudButton>
            <MudButton Variant="Variant.Text" Href="samples/banking-sample.csv" Target="_blank">@Localizer["Banking_Empty_DownloadSample"]</MudButton>
        </MudStack>
    </MudAlert>
}

@if (_selectedTransaction is not null)
{
    <MudPaper Class="pa-4 mt-4">
        <MudText Typo="Typo.subtitle1">@Localizer["Banking_Action_Match"] - @_selectedTransaction.Counterparty (@($"{_selectedTransaction.Amount:0.00} EUR"))</MudText>
        <MudAlert Severity="Severity.Info" Dense="true" Variant="Variant.Text" Class="mb-3">
            @Localizer["Banking_Match_Note"]
        </MudAlert>
        <MudAutocomplete T="InvoiceLookup"
                         ToStringFunc="@(invoice => $"{invoice.Number} - {invoice.Counterparty} ({invoice.TotalGross:0.00})")"
                         SearchFunc="SearchInvoicesAsync"
                         Dense="true"
                         Placeholder="@Localizer["Banking_Match_SelectInvoice"]"
                         @bind-Value="_selectedInvoice" />
        <MudText Typo="Typo.caption" Class="mt-1">@Localizer["Banking_Match_Helper"]</MudText>
        <MudStack Row="true" Justify="Justify.FlexEnd" Class="mt-2" Spacing="2">
            <MudButton Variant="Variant.Text" OnClick="() => _selectedTransaction = null">@Localizer["Banking_Match_Cancel"]</MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="_selectedInvoice is null" OnClick="MatchSelectedInvoiceAsync">@Localizer["Banking_Match_Save"]</MudButton>
        </MudStack>
    </MudPaper>
}

@code {
    private readonly List<BankTransactionRow> _transactions = new();
    private readonly CancellationTokenSource _disposeCts = new();
    private CancellationTokenSource? _loadCts;
    private BankTransactionRow? _selectedTransaction;
    private InvoiceLookup? _selectedInvoice;
    private IBrowserFile? _importFile;
    private bool _isLoading;
    private DateTime? _filterFrom;
    private DateTime? _filterTo;
    private bool? _filterMatched;
    private string? _searchTerm;
    private decimal? _amountMin;
    private decimal? _amountMax;
    private bool _hasAnnouncedInitialLoad;
    private OperationSummary? _lastOperationSummary;
    private IEnumerable<BankTransactionRow> FilteredTransactions => _transactions.Where(MatchesClientFilters);

    protected override async Task OnInitializedAsync()
    {
        await LoadTransactionsAsync();
    }

    private async Task LoadTransactionsAsync()
    {
        var token = BeginLoadCts();
        try
        {
            _isLoading = true;
            var query = new Dictionary<string, string?>();
            DateOnly? from = _filterFrom.HasValue ? DateOnly.FromDateTime(_filterFrom.Value.Date) : null;
            if (from.HasValue)
            {
                query["from"] = from.Value.ToString("yyyy-MM-dd");
            }

            DateOnly? to = _filterTo.HasValue ? DateOnly.FromDateTime(_filterTo.Value.Date) : null;
            if (to.HasValue)
            {
                query["to"] = to.Value.ToString("yyyy-MM-dd");
            }

            if (_filterMatched.HasValue)
            {
                query["matched"] = _filterMatched.Value ? "true" : "false";
            }

            var endpoint = query.Count > 0
                ? QueryHelpers.AddQueryString("api/banking/transactions", query)
                : "api/banking/transactions";
            var transactions = await Http.GetFromJsonAsync<List<BankTransactionDto>>(endpoint, token) ?? new List<BankTransactionDto>();
            _transactions.Clear();
            _transactions.AddRange(transactions.Select(t => new BankTransactionRow(t.Id, t.BookingDate, t.Counterparty, t.Reference, t.Amount, t.MatchedInvoiceId, t.JournalEntryId)));
            if (!_hasAnnouncedInitialLoad)
            {
                Snackbar.Add(Localizer["Banking_Snackbar_Loaded"].Value, Severity.Info);
                _hasAnnouncedInitialLoad = true;
            }
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load bank transactions");
            Snackbar.Add(Localizer["Banking_Error_Load", ex.Message].Value, Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task SyncExternalAsync()
    {
        try
        {
            var response = await Http.PostAsync("api/banking/transactions/sync", null, _disposeCts.Token);
            response.EnsureSuccessStatusCode();
            Snackbar.Add(Localizer["Banking_Snackbar_Synced"].Value, Severity.Success);
            var synced = await response.Content.ReadFromJsonAsync<List<BankTransactionDto>>(_disposeCts.Token) ?? new List<BankTransactionDto>();
            var matchResult = await RequestAutoMatchAsync();
            UpdateSummary(Localizer["Banking_Summary_Source_Sync"].Value, synced.Count, matchResult);
            await LoadTransactionsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to sync external transactions");
            Snackbar.Add(Localizer["Banking_Error_Sync", ex.Message].Value, Severity.Error);
        }
    }

    private Task HandleRowClick(TableRowClickEventArgs<BankTransactionRow> args)
    {
        _selectedTransaction = args.Item;
        _selectedInvoice = null;
        return Task.CompletedTask;
    }

    private async Task<IEnumerable<InvoiceLookup>> SearchInvoicesAsync(string value, CancellationToken cancellationToken)
    {
        var invoices = await InvoiceService.GetAsync(null, null, null, cancellationToken);
        return invoices
            .Where(i => i.CanRegisterPayment)
            .Where(i => string.IsNullOrWhiteSpace(value) || i.Number.Contains(value, StringComparison.OrdinalIgnoreCase))
            .Select(i => new InvoiceLookup(i.Id, i.Number, i.Counterparty, i.TotalGross("EUR").Amount));
    }

    private async Task MatchSelectedInvoiceAsync()
    {
        if (_selectedTransaction is null || _selectedInvoice is null)
        {
            return;
        }

        try
        {
            var response = await Http.PostAsync($"api/banking/transactions/{_selectedTransaction.Id}/link/{_selectedInvoice.Id}", content: null, _disposeCts.Token);
            response.EnsureSuccessStatusCode();
            Snackbar.Add(Localizer["Banking_Snackbar_Matched"].Value, Severity.Success);
            _selectedTransaction = null;
            _selectedInvoice = null;
            await LoadTransactionsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to match transaction {TransactionId} to invoice {InvoiceId}", _selectedTransaction?.Id, _selectedInvoice?.Id);
            Snackbar.Add(Localizer["Banking_Error_Match", ex.Message].Value, Severity.Error);
        }
    }

    private async Task ImportCsvAsync()
    {
        if (_importFile is null)
        {
            return;
        }

        try
        {
            var content = new MultipartFormDataContent();
            var stream = _importFile.OpenReadStream(5 * 1024 * 1024);
            var streamContent = new StreamContent(stream);
            streamContent.Headers.ContentType = new MediaTypeHeaderValue(_importFile.ContentType ?? "text/csv");
            content.Add(streamContent, "file", _importFile.Name);
            var response = await Http.PostAsync("api/banking/transactions/import", content, _disposeCts.Token);
            response.EnsureSuccessStatusCode();
            Snackbar.Add(Localizer["Banking_Snackbar_Imported"].Value, Severity.Success);
            _importFile = null;
            var importedTransactions = await response.Content.ReadFromJsonAsync<List<BankTransactionDto>>(_disposeCts.Token) ?? new List<BankTransactionDto>();
            var matchResult = await RequestAutoMatchAsync();
            UpdateSummary(Localizer["Banking_Summary_Source_Import"].Value, importedTransactions.Count, matchResult);
            await LoadTransactionsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to import CSV");
            Snackbar.Add(Localizer["Banking_Error_Import", ex.Message].Value, Severity.Error);
        }
    }

    private async Task TriggerAutoMatchAsync()
    {
        try
        {
            var result = await RequestAutoMatchAsync();
            UpdateSummary(Localizer["Banking_Summary_Source_Auto"].Value, 0, result);
            if (result is { Matched: > 0 } || result is { JournalEntriesCreated: > 0 })
            {
                Snackbar.Add(Localizer["Banking_AutoMatch_Success", result!.Matched].Value, Severity.Success);
                await LoadTransactionsAsync();
            }
            else
            {
                Snackbar.Add(Localizer["Banking_AutoMatch_None"].Value, Severity.Info);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to auto-match transactions");
            Snackbar.Add(Localizer["Banking_Error_AutoMatch", ex.Message].Value, Severity.Error);
        }
    }

    private async Task<AutoMatchResultDto?> RequestAutoMatchAsync()
    {
        var response = await Http.PostAsync("api/banking/transactions/auto-match", null, _disposeCts.Token);
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadFromJsonAsync<AutoMatchResultDto>(_disposeCts.Token);
    }

    private void UpdateSummary(string source, int imported, AutoMatchResultDto? result)
    {
        _lastOperationSummary = new OperationSummary(
            source,
            imported,
            result?.Matched ?? 0,
            result?.JournalEntriesCreated ?? 0);
    }

    private bool MatchesClientFilters(BankTransactionRow transaction)
    {
        if (!string.IsNullOrWhiteSpace(_searchTerm))
        {
            var term = _searchTerm.Trim();
            if (!(transaction.Counterparty.Contains(term, StringComparison.OrdinalIgnoreCase) ||
                  transaction.Reference.Contains(term, StringComparison.OrdinalIgnoreCase)))
            {
                return false;
            }
        }

        if (_amountMin.HasValue && transaction.Amount < _amountMin.Value)
        {
            return false;
        }

        if (_amountMax.HasValue && transaction.Amount > _amountMax.Value)
        {
            return false;
        }

        return true;
    }

    private sealed record BankTransactionRow(Guid Id, DateOnly BookingDate, string Counterparty, string Reference, decimal Amount, Guid? MatchedInvoiceId, Guid? JournalEntryId);

    private sealed record InvoiceLookup(Guid Id, string Number, string Counterparty, decimal TotalGross);

    private sealed record OperationSummary(string Source, int ImportedCount, int MatchedCount, int JournalEntries);

    private CancellationToken BeginLoadCts()
    {
        _loadCts?.Cancel();
        _loadCts?.Dispose();
        _loadCts = CancellationTokenSource.CreateLinkedTokenSource(_disposeCts.Token);
        return _loadCts.Token;
    }

    public void Dispose()
    {
        _loadCts?.Cancel();
        _loadCts?.Dispose();
        _disposeCts.Cancel();
        _disposeCts.Dispose();
    }
}
