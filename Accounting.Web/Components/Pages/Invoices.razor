@page "/invoices"
@using Accounting.Core.Entities
@using Accounting.Core.Enums
@using Accounting.Core.ValueObjects
@using MudBlazor
@inject IInvoiceService InvoiceService
@inject IChartOfAccountsService ChartService
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IStringLocalizer<SharedResources> Localizer
@inject ILogger<Invoices> Logger
@implements IDisposable

<MudPaper Class="pa-4 mb-4">
    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
        <MudText Typo="Typo.h5">@Localizer["Invoices_Title"]</MudText>
        <MudTooltip Text="@Localizer["Invoices_Tooltip_Add"]">
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="OpenCreateDialogAsync">
                <MudIcon Icon="@Icons.Material.Filled.Add" Class="mr-2" />@Localizer["Invoices_AddButton"]
            </MudButton>
        </MudTooltip>
    </MudStack>

    <MudStack Row="true" Class="mt-4" Spacing="2">
        <MudSelect T="InvoiceType?" Value="_filterType" ValueChanged="OnFilterChanged" Label="@Localizer["Invoices_Filter_Type"]">
            <MudSelectItem Value="@( (InvoiceType?)null )">@Localizer["Invoices_Filter_AllTypes"]</MudSelectItem>
            @foreach (InvoiceType type in Enum.GetValues(typeof(InvoiceType)))
            {
                <MudSelectItem Value="@( (InvoiceType?)type )">@Localizer[$"Invoice_Type_{type}"]</MudSelectItem>
            }
        </MudSelect>
        <MudDatePicker Date="_fromDate" DateChanged="value => OnDateChanged(value, true)" Label="@Localizer["Invoices_Filter_From"]" />
        <MudDatePicker Date="_toDate" DateChanged="value => OnDateChanged(value, false)" Label="@Localizer["Invoices_Filter_To"]" />
    </MudStack>
</MudPaper>

<MudPaper Class="report-note">
    @Localizer["Invoices_Note"]
</MudPaper>

@if (_isLoading)
{
    <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
}
else if (_invoices.Count == 0)
{
    <MudText Typo="Typo.subtitle1">@Localizer["Invoices_NoRecords"]</MudText>
}
else
{
    <MudTable Items="_invoices" Dense="true">
        <HeaderContent>
            <MudTh>@Localizer["Invoices_Table_Number"]</MudTh>
            <MudTh>@Localizer["Invoices_Table_Type"]</MudTh>
            <MudTh>@Localizer["Invoices_Table_Counterparty"]</MudTh>
            <MudTh>@Localizer["Invoices_Table_IssueDate"]</MudTh>
            <MudTh>@Localizer["Invoices_Table_DueDate"]</MudTh>
            <MudTh>@Localizer["Invoices_Table_Total"]</MudTh>
            <MudTh>@Localizer["Invoices_Table_Status"]</MudTh>
            <MudTh></MudTh>
        </HeaderContent>
        <RowTemplate Context="invoice">
            <MudTd>@invoice.Number</MudTd>
            <MudTd>@Localizer[$"Invoice_Type_{invoice.Type}"]</MudTd>
            <MudTd>@invoice.Counterparty</MudTd>
            <MudTd>@invoice.IssueDate.ToString("yyyy-MM-dd")</MudTd>
            <MudTd>@invoice.DueDate.ToString("yyyy-MM-dd")</MudTd>
            <MudTd>@invoice.TotalGross</MudTd>
            <MudTd>
                <MudStack>
                    <MudChip T="string" Color="@GetWorkflowColor(invoice.WorkflowStatus)">
                        @Localizer[$"Invoices_Workflow_{invoice.WorkflowStatus}"]
                    </MudChip>
                    <MudChip T="bool" Value="invoice.IsPosted" Color="invoice.IsPosted ? Color.Success : Color.Warning" Variant="Variant.Outlined" Size="Size.Small">
                        @(invoice.IsPosted ? Localizer["Invoices_Status_Posted"] : Localizer["Invoices_Status_Draft"])
                    </MudChip>
                </MudStack>
            </MudTd>
            <MudTd>
                <MudStack Row="true" Class="invoice-actions" AlignItems="AlignItems.Center" Spacing="1">
                    <MudTooltip Text="@Localizer["Invoices_Action_Send"]">
                        <MudIconButton Icon="@Icons.Material.Filled.Send"
                                       Color="Color.Info"
                                       Variant="Variant.Outlined"
                                       Disabled="!invoice.CanMarkAsSent"
                                       OnClick="() => MarkAsSentAsync(invoice)" />
                    </MudTooltip>
                    <MudTooltip Text="@Localizer["Invoices_Action_RecordPayment"]">
                        <MudIconButton Icon="@Icons.Material.Filled.AttachMoney"
                                       Color="Color.Success"
                                       Variant="Variant.Outlined"
                                       Disabled="!invoice.CanRegisterPayment"
                                       OnClick="() => OpenRecordPaymentDialogAsync(invoice)" />
                    </MudTooltip>
                    <MudTooltip Text="@Localizer["Invoices_Action_DownloadPdf"]">
                        <MudIconButton Icon="@Icons.Material.Filled.PictureAsPdf"
                                       Color="Color.Secondary"
                                       Variant="Variant.Outlined"
                                       Href="@($"/api/invoices/{invoice.Id}/pdf")"
                                       Target="_blank" />
                    </MudTooltip>
                    @if (!invoice.IsPosted)
                    {
                        <MudTooltip Text="@Localizer["Invoices_Action_Post"]">
                            <MudIconButton Icon="@Icons.Material.Filled.Check"
                                           Color="Color.Info"
                                           Variant="Variant.Outlined"
                                           OnClick="() => PostInvoiceAsync(invoice.Id)" />
                        </MudTooltip>
                        <MudTooltip Text="@Localizer["Invoices_Action_Delete"]">
                            <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                           Color="Color.Error"
                                           Variant="Variant.Outlined"
                                           OnClick="() => DeleteInvoiceAsync(invoice.Id)" />
                        </MudTooltip>
                    }
                </MudStack>
            </MudTd>
        </RowTemplate>
        <ChildRowContent Context="invoice">
            <MudPaper Class="pa-3">
                <MudTable Items="@invoice.Lines" Dense="true">
                    <HeaderContent>
                        <MudTh>@Localizer["Invoice_Lines_Description"]</MudTh>
                        <MudTh>@Localizer["Invoice_Lines_Quantity"]</MudTh>
                        <MudTh>@Localizer["Invoice_Lines_UnitPrice"]</MudTh>
                        <MudTh>@Localizer["Invoice_Lines_Vat"]</MudTh>
                        <MudTh>@Localizer["Invoice_Lines_Total"]</MudTh>
                    </HeaderContent>
                    <RowTemplate Context="line">
                        <MudTd>@line.Description</MudTd>
                        <MudTd>@line.Quantity</MudTd>
                        <MudTd>@line.UnitPrice</MudTd>
                        <MudTd>@line.VatRate %</MudTd>
                        <MudTd>@line.LineTotal</MudTd>
                    </RowTemplate>
                </MudTable>
            </MudPaper>
        </ChildRowContent>
    </MudTable>
}

@code {
    private readonly List<InvoiceViewModel> _invoices = new();
    private readonly CancellationTokenSource _disposeCts = new();
    private CancellationTokenSource? _loadCts;
    private IReadOnlyList<InvoiceDialog.AccountOption> _accounts = Array.Empty<InvoiceDialog.AccountOption>();
    private bool _isLoading;
    private InvoiceType? _filterType;
    private DateTime? _fromDate = DateTime.Today.AddMonths(-1);
    private DateTime? _toDate = DateTime.Today;

    protected override async Task OnInitializedAsync()
    {
        var token = _disposeCts.Token;
        var accountList = await ChartService.GetAsync(AccountCategory.Revenue, token);
        _accounts = accountList.Select(a => new InvoiceDialog.AccountOption(a.Id, a.Number, a.Name)).ToList();
        await LoadInvoicesAsync();
    }

    private async Task LoadInvoicesAsync()
    {
        _isLoading = true;
        var token = BeginLoadCts();
        try
        {
            _invoices.Clear();
            var invoices = await InvoiceService.GetAsync(_filterType, ConvertToDateOnly(_fromDate), ConvertToDateOnly(_toDate), token);
            _invoices.AddRange(invoices.Select(InvoiceViewModel.FromEntity));
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load invoices");
            Snackbar.Add(ex.Message, Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task OnFilterChanged(InvoiceType? type)
    {
        _filterType = type;
        await LoadInvoicesAsync();
    }

    private async Task OnDateChanged(DateTime? value, bool isFrom)
    {
        if (isFrom)
            _fromDate = value;
        else
            _toDate = value;

        await LoadInvoicesAsync();
    }

    private async Task OpenCreateDialogAsync()
    {
        var parameters = new DialogParameters
        {
            { nameof(InvoiceDialog.Model), new InvoiceDialog.InvoiceEditModel() },
            { nameof(InvoiceDialog.Accounts), _accounts }
        };

        var options = new DialogOptions { CloseButton = true, FullWidth = true, MaxWidth = MaxWidth.ExtraLarge };
        var dialog = await DialogService.ShowAsync<InvoiceDialog>(Localizer["Invoice_Dialog_Title"], parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: InvoiceDialog.InvoiceEditModel model })
        {
            await CreateInvoiceAsync(model);
        }
    }

    private async Task CreateInvoiceAsync(InvoiceDialog.InvoiceEditModel model)
    {
        try
        {
            var lines = model.Lines.Select(l => new InvoiceLine(l.Description, l.Quantity, new Money(l.UnitPrice, "EUR"), l.VatRate, l.RevenueAccountId!.Value));
            await InvoiceService.CreateAsync(model.Type, model.Number, model.Counterparty, model.IssueDate, model.DueDate, lines, _disposeCts.Token);
            Snackbar.Add(Localizer["Invoices_Snackbar_Create"].Value, Severity.Success);
            await LoadInvoicesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to create invoice {Number}", model.Number);
            Snackbar.Add(ex.Message, Severity.Error);
        }
    }

    private async Task PostInvoiceAsync(Guid id)
    {
        try
        {
            await InvoiceService.PostAsync(id, _disposeCts.Token);
            Snackbar.Add(Localizer["Invoices_Snackbar_Posted"].Value, Severity.Success);
            await LoadInvoicesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to post invoice {InvoiceId}", id);
            Snackbar.Add(ex.Message, Severity.Error);
        }
    }

    private async Task MarkAsSentAsync(InvoiceViewModel invoice)
    {
        if (!invoice.CanMarkAsSent)
        {
            return;
        }

        try
        {
            var today = DateOnly.FromDateTime(DateTime.Today);
            await InvoiceService.MarkSentAsync(invoice.Id, today, _disposeCts.Token);
            Snackbar.Add(Localizer["Invoices_Snackbar_Sent"].Value, Severity.Success);
            await LoadInvoicesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to mark invoice {InvoiceId} as sent", invoice.Id);
            Snackbar.Add(ex.Message, Severity.Error);
        }
    }

    private async Task OpenRecordPaymentDialogAsync(InvoiceViewModel invoice)
    {
        if (!invoice.CanRegisterPayment)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { nameof(RecordPaymentDialog.InitialDate), DateOnly.FromDateTime(DateTime.Today) }
        };

        var dialog = await DialogService.ShowAsync<RecordPaymentDialog>(
            Localizer["Invoice_PaymentDialog_Title", invoice.Number],
            parameters);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: DateOnly paymentDate })
        {
            await RecordPaymentAsync(invoice.Id, paymentDate);
        }
    }

    private async Task RecordPaymentAsync(Guid invoiceId, DateOnly paymentDate)
    {
        try
        {
            await InvoiceService.RecordPaymentAsync(invoiceId, paymentDate, _disposeCts.Token);
            Snackbar.Add(Localizer["Invoices_Snackbar_Paid"].Value, Severity.Success);
            await LoadInvoicesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to record payment for invoice {InvoiceId}", invoiceId);
            Snackbar.Add(ex.Message, Severity.Error);
        }
    }

    private async Task DeleteInvoiceAsync(Guid id)
    {
        try
        {
            await InvoiceService.DeleteAsync(id, _disposeCts.Token);
            Snackbar.Add(Localizer["Invoices_Snackbar_Delete"].Value, Severity.Info);
            await LoadInvoicesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to delete invoice {InvoiceId}", id);
            Snackbar.Add(ex.Message, Severity.Error);
        }
    }

    private Color GetWorkflowColor(InvoiceWorkflowStatus status) => status switch
    {
        InvoiceWorkflowStatus.Draft => Color.Info,
        InvoiceWorkflowStatus.Sent => Color.Secondary,
        InvoiceWorkflowStatus.Paid => Color.Success,
        InvoiceWorkflowStatus.Overdue => Color.Error,
        _ => Color.Default
    };

    private sealed record InvoiceViewModel(Guid Id, InvoiceType Type, string Number, string Counterparty, DateOnly IssueDate, DateOnly DueDate, InvoiceWorkflowStatus WorkflowStatus, bool IsPosted, bool CanMarkAsSent, bool CanRegisterPayment, decimal TotalGross, IReadOnlyList<InvoiceLineViewModel> Lines)
    {
        public static InvoiceViewModel FromEntity(Invoice invoice)
        {
            var currency = "EUR";
            var lines = invoice.Lines.Select(l => new InvoiceLineViewModel(l.Description, l.Quantity, l.UnitPrice.Amount, l.VatRate, l.Total.Amount)).ToList();
            return new InvoiceViewModel(
                invoice.Id,
                invoice.Type,
                invoice.Number,
                invoice.Counterparty,
                invoice.IssueDate,
                invoice.DueDate,
                invoice.WorkflowStatus,
                invoice.IsPosted,
                invoice.CanMarkAsSent,
                invoice.CanRegisterPayment,
                invoice.TotalGross(currency).Amount,
                lines);
        }
    }

    private sealed record InvoiceLineViewModel(string Description, decimal Quantity, decimal UnitPrice, decimal VatRate, decimal LineTotal);

    private static DateOnly? ConvertToDateOnly(DateTime? dateTime)
        => dateTime.HasValue ? DateOnly.FromDateTime(dateTime.Value) : null;

    private CancellationToken BeginLoadCts()
    {
        _loadCts?.Cancel();
        _loadCts?.Dispose();
        _loadCts = CancellationTokenSource.CreateLinkedTokenSource(_disposeCts.Token);
        return _loadCts.Token;
    }

    public void Dispose()
    {
        _loadCts?.Cancel();
        _loadCts?.Dispose();
        _disposeCts.Cancel();
        _disposeCts.Dispose();
    }
}
